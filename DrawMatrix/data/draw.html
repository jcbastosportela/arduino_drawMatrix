const char DRAW_HTML[] PROGMEM = R"html(
<!-- This file starts with `R"html(` so it can be included as a Raw literal string in c++  -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#1a1a1a">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="application-name" content="LED Draw">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="LED Draw">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="description" content="8x8 LED Matrix Drawing Tool">
  <link rel="manifest" href='data:application/manifest+json,{
    "name": "LED Matrix Draw",
    "short_name": "LED Draw",
    "display": "fullscreen",
    "orientation": "any",
    "start_url": ".",
    "id": "/draw",
    "scope": "/",
    "background_color": "#1a1a1a",
    "theme_color": "#1a1a1a",
    "categories": ["utilities"],
    "launch_handler": {
      "client_mode": ["focus-existing", "auto"]
    },
    "icons": [{
      "src": "data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 512 512\'%3E%3Crect width=\'512\' height=\'512\' fill=\'%232d2d2d\'/%3E%3Cpath d=\'M96 96h320v320H96z\' fill=\'%23222\'/%3E%3C/svg%3E",
      "sizes": "512x512",
      "type": "image/svg+xml",
      "purpose": "any maskable"
    }]
  }'>
  <title>LED Matrix Draw</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(function() {});
    }
    // Prevent pinch zoom
    document.addEventListener('touchmove', function(e) {
      if (e.scale !== 1) {
        e.preventDefault();
      }
    }, { passive: false });
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      width: 100vw;
      max-width: 100vw;
      margin: 0;
      padding: 0;
      overflow-x: auto;
      overflow-y: auto;
      position: static;
    }

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a1a;
      padding: 8px 0 8px 0;
      min-height: 100vh;
      box-sizing: border-box;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: center;
      width: 100vw;
      max-width: 100vw;
      padding: 8px 0 8px 0;
      background: #2d2d2d;
      border-radius: 0;
      box-shadow: none;
      box-sizing: border-box;
    }

    table {
      border-collapse: collapse;
      background: #222;
      border-radius: 8px;
      width: 98vw;
      max-width: 98vw;
      height: auto;
      aspect-ratio: 32 / 24;
      table-layout: fixed;
      border-spacing: 0;
      margin: 0 auto;
      touch-action: none;
      display: block;
      overflow-x: auto;
    }

    td {
      position: relative;
      width: calc(98vw / 32);
      height: calc(98vw / 32);
      aspect-ratio: 1 / 1;
      border: 2px solid #333;
      cursor: pointer;
      transition: border-color 0.2s;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
    }

    td::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      right: 2px;
      bottom: 2px;
      background-color: inherit;
      border-radius: 2px;
    }

    td:hover {
      border-color: #555;
    }

    .color-controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
      padding: 12px;
      background: #222;
      border-radius: 8px;
    }

    .rgb-control {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .rgb-control label {
      color: #fff;
      font-size: 0.9em;
      width: 60px;
    }

    .rgb-control span {
      color: #fff;
      font-size: 0.8em;
      opacity: 0.6;
      width: 30px;
      text-align: right;
    }

    .rgb-control input[type="range"] {
      flex: 1;
    }

    .color-preview {
      width: 100%;
      height: 40px;
      border-radius: 4px;
      background: #000;
      margin-top: 8px;
      border: 2px solid #333;
    }

    .control-group {
      display: flex;
      gap: 12px;
      width: 100%;
      align-items: center;
    }

    .brightness-control {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .brightness-control label {
      color: #fff;
      font-size: 0.9em;
      opacity: 0.8;
    }

    .brightness-control span {
      color: #fff;
      font-size: 0.8em;
      opacity: 0.6;
      text-align: right;
    }

    input[type="range"] {
      width: 100%;
      height: 32px;  /* Increased touch area */
      background: linear-gradient(to bottom, transparent 8px, #222 8px, #222 24px, transparent 24px);
      border-radius: 3px;
      appearance: none;
      outline: none;
      touch-action: pan-x;  /* Allow horizontal sliding */
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 24px;  /* Larger thumb */
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.2s;
      transform: translateY(-1px); /* Center the thumb */
    }

    #red::-webkit-slider-thumb {
      background: #ff0000;
    }
    #red::-webkit-slider-thumb:hover {
      background: #dd0000;
    }

    #green::-webkit-slider-thumb {
      background: #00ff00;
    }
    #green::-webkit-slider-thumb:hover {
      background: #00dd00;
    }

    #blue::-webkit-slider-thumb {
      background: #0000ff;
    }
    #blue::-webkit-slider-thumb:hover {
      background: #0000dd;
    }

    #brightness::-webkit-slider-thumb {
      background: #4CAF50;
    }
    #brightness::-webkit-slider-thumb:hover {
      background: #45a049;
    }

    .button-group {
      display: flex;
      gap: 12px;
      width: 100%;
    }

    .button-group button {
      flex: 1;
    }

    .status-indicator {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #4CAF50;
      transition: background-color 0.3s;
    }

    .status-indicator.offline {
      background-color: #d32f2f;
    }

    .status-indicator.reconnecting {
      background-color: #ff9800;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      50% { opacity: 0.5; }
    }

    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 14px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 500;
      width: 100%;
      transition: transform 0.1s, opacity 0.2s;
    }

    button:hover {
      opacity: 0.9;
    }

    button:active {
      transform: scale(0.98);
    }

    #sendMatrix {
      background: linear-gradient(45deg, #4776E6, #8E54E9);
    }
  </style>
</head>

<body>    
    <div class="status-indicator" id="statusIndicator" title="Server Status"></div>
    <div class="controls">
    <div class="color-controls">
      <div class="rgb-control">
        <label for="red">üî¥ Red</label>
        <input type="range" id="red" min="0" max="255" value="0">
        <span id="redValue">0</span>
      </div>
      <div class="rgb-control">
        <label for="green">üü¢ Green</label>
        <input type="range" id="green" min="0" max="255" value="0">
        <span id="greenValue">0</span>
      </div>
      <div class="rgb-control">
        <label for="blue">üîµ Blue</label>
        <input type="range" id="blue" min="0" max="255" value="0">
        <span id="blueValue">0</span>
      </div>
    </div>
    <div class="control-group">
      <div class="brightness-control">
        <label for="brightness">üí° Brightness</label>
        <input type="range" id="brightness" min="0" max="255" value="50">
        <span id="brightnessValue">20%</span>
      </div>
    </div>
    <div class="button-group">
      <button onclick="fillAll()">üé® Fill</button>
      <button onclick="clearMatrix()" style="background-color: #000000">üßπ Clear</button>
      <input type="file" id="importImage" accept="image/*" style="display:none" />
      <button onclick="document.getElementById('importImage').click()">üñºÔ∏è Import Image</button>
    </div>
    <table id="matrix"></table>
  <button id="sendMatrix" onclick="sendMatrixDebounced()">‚ú® Update Matrix</button>
  </div>
  </style>
  <script>
  const rows = 32, cols = 24;
  let matrix = Array.from({ length: rows }, () => Array(cols).fill('#000000'));
    const table = document.getElementById('matrix');
    const redSlider = document.getElementById('red');
    const statusIndicator = document.getElementById('statusIndicator');
    let isConnected = true;
    let reconnectAttempts = 0;
    let pendingUpdates = [];
    const greenSlider = document.getElementById('green');
    const blueSlider = document.getElementById('blue');
    let updateTimeout = null;
    const redValue = document.getElementById('redValue');
    const greenValue = document.getElementById('greenValue');
    const blueValue = document.getElementById('blueValue');
    const colorPreview = document.getElementById('colorPreview');
    const fillButton = document.querySelector('button');  // First button is Fill All
    let isPainting = false;

    function updateColor() {
      const r = parseInt(redSlider.value);
      const g = parseInt(greenSlider.value);
      const b = parseInt(blueSlider.value);
      const color = '#' + 
        (r < 16 ? '0' : '') + r.toString(16) +
        (g < 16 ? '0' : '') + g.toString(16) +
        (b < 16 ? '0' : '') + b.toString(16);
      fillButton.style.backgroundColor = color;
      redValue.textContent = r;
      greenValue.textContent = g;
      blueValue.textContent = b;
      return color;
    }

    // Handle both touch and mouse events for sliders
    const sliders = [redSlider, greenSlider, blueSlider];
    
    sliders.forEach(slider => {
      slider.addEventListener('input', updateColor);
      
      // Touch event handling for mobile
      slider.addEventListener('touchstart', function(e) {
        e.preventDefault();
        updateSliderValue(e, this);
      });
      
      slider.addEventListener('touchmove', function(e) {
        e.preventDefault();
        updateSliderValue(e, this);
      });
    });
    
    function updateSliderValue(e, slider) {
      const touch = e.touches[0];
      const rect = slider.getBoundingClientRect();
      const position = touch.clientX - rect.left;
      const percentage = Math.max(0, Math.min(1, position / rect.width));
      slider.value = Math.round(percentage * 255);
      updateColor();
    }
    
    // Set initial color
    updateColor();

    // Handle brightness control
    const brightnessSlider = document.getElementById('brightness');
    const brightnessValue = document.getElementById('brightnessValue');

    function updateBrightness() {
      const value = brightnessSlider.value;
      const percentage = Math.round((value / 255) * 100);
      brightnessValue.textContent = percentage + '%';
      fetch('/set_display_brightness?value=' + value)
        .then(response => response.text())
        .then(result => console.log(result))
        .catch(error => console.error('Error:', error));
    }

    brightnessSlider.addEventListener('change', updateBrightness); // Fires on release (mouse/touch)

    // Touch event handling for mobile (like color sliders)
    let brightnessActive = false;
    brightnessSlider.addEventListener('touchstart', function(e) {
      e.preventDefault();
      brightnessActive = true;
      updateBrightnessSliderValue(e, this);
    });
    brightnessSlider.addEventListener('touchmove', function(e) {
      e.preventDefault();
      updateBrightnessSliderValue(e, this);
    });
    brightnessSlider.addEventListener('mousedown', function(e) {
      brightnessActive = true;
    });
    document.addEventListener('touchend', function(e) {
      if (brightnessActive) {
        updateBrightness();
        brightnessActive = false;
      }
    });
    document.addEventListener('mouseup', function(e) {
      if (brightnessActive) {
        updateBrightness();
        brightnessActive = false;
      }
    });

    function updateBrightnessSliderValue(e, slider) {
      const touch = e.touches[0];
      const rect = slider.getBoundingClientRect();
      const position = touch.clientX - rect.left;
      const percentage = Math.max(0, Math.min(1, position / rect.width));
      slider.value = Math.round(percentage * 255);
    }

    // Render the matrix table (rotated 90¬∞ clockwise for display only)
    function renderMatrixTable() {
      table.innerHTML = '';
      for (let y = 0; y < cols; y++) { // y is row, x is col
        const tr = document.createElement('tr');
        for (let x = 0; x < rows; x++) {
          const td = document.createElement('td');
          td.style.backgroundColor = matrix[x][y];
          // Mouse events
          td.addEventListener('mousedown', (e) => {
            isPainting = true;
            paintCell(td, x, y);
          });
          td.addEventListener('mousemove', (e) => {
            if (isPainting) paintCell(td, x, y);
          });
          // Touch events for drag painting
          td.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isPainting = true;
            paintCell(td, x, y);
          });
          td.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target && target.tagName === 'TD') {
              // Find the cell's x and y
              const parentTr = target.parentElement;
              const rowIdx = Array.from(table.rows).indexOf(parentTr);
              const colIdx = Array.from(parentTr.children).indexOf(target);
              if (rowIdx !== -1 && colIdx !== -1) {
                paintCell(target, colIdx, rowIdx);
              }
            }
          });
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }
    }
    renderMatrixTable();
    document.addEventListener('mouseup', () => { isPainting = false; });
    document.addEventListener('touchend', () => { isPainting = false; });

    function checkConnection() {
      fetch('/set_display_brightness?value=' + brightnessSlider.value, { timeout: 2000 })
        .then(() => {
          if (!isConnected) {
            console.log('Connection restored');
            isConnected = true;
            reconnectAttempts = 0;
            statusIndicator.className = 'status-indicator';
            // Resend any pending updates
            if (pendingUpdates.length > 0) {
              sendMatrixDebounced();
            }
          }
        })
        .catch(() => {
          if (isConnected) {
            console.log('Connection lost');
            isConnected = false;
            statusIndicator.className = 'status-indicator offline';
          }
          // Try to reconnect with exponential backoff
          reconnectAttempts++;
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 30000);
          statusIndicator.className = 'status-indicator reconnecting';
          setTimeout(checkConnection, delay);
        });
    }

    // Check connection status every 5 seconds
    setInterval(checkConnection, 5000);
    checkConnection(); // Initial check

    function sendMatrixDebounced() {
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      updateTimeout = setTimeout(() => {
        if (!isConnected) {
          console.log('Update queued - offline');
          pendingUpdates.push(true);
          return;
        }
        fetch('set_display_matrix', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(matrix)
        })
        .then(() => {
          pendingUpdates = [];
        })
        .catch(error => {
          console.error('Error:', error);
          checkConnection(); // Immediate connection check on error
        });
      }, 100); // 100ms debounce
    }

    function paintCell(cell, visualRow, visualCol) {
  // Standard orientation: x is col, y is row
  const color = updateColor();
  matrix[visualRow][visualCol] = color;
  cell.style.backgroundColor = color;
  sendMatrixDebounced();
    }

    // Handle mouse events
    table.addEventListener('mousedown', (e) => {
      isPainting = true;
      if (e.target.tagName === 'TD') {
        paintCell(e.target);
      }
    });

    table.addEventListener('mousemove', (e) => {
      if (isPainting && e.target.tagName === 'TD') {
        paintCell(e.target);
      }
    });

    document.addEventListener('mouseup', () => {
      isPainting = false;
    });

    // Handle touch events
    table.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isPainting = true;
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell.tagName === 'TD') {
        paintCell(cell);
      }
    });

    table.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isPainting) {
        const touch = e.touches[0];
        const cell = document.elementFromPoint(touch.clientX, touch.clientY);
        if (cell && cell.tagName === 'TD') {
          paintCell(cell);
        }
      }
    });

    document.addEventListener('touchend', () => {
      isPainting = false;
    });

    function fillAll() {
      const color = updateColor();
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          matrix[r][c] = color;
        }
      }
      renderMatrixTable();
      sendMatrixDebounced();
    }

    function clearMatrix() {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          matrix[r][c] = '#000000';
        }
      }
      renderMatrixTable();
      sendMatrixDebounced();
    }

    function sendMatrix() {
      fetch('set_display_matrix', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(matrix)
      }).then(r => r.text()).then(alert);
    }


  // Image import and conversion logic
  const importImageInput = document.getElementById('importImage');
  importImageInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(ev) {
      const img = new Image();
      img.onload = function() {
        // Create a canvas to resize the image with 'cover' logic
        const canvas = document.createElement('canvas');
        canvas.width = rows;
        canvas.height = cols;
        const ctx = canvas.getContext('2d');
        // Calculate aspect ratios
        const matrixAspect = rows / cols;
        const imgAspect = img.width / img.height;
        let drawWidth, drawHeight, offsetX, offsetY;
        if (imgAspect > matrixAspect) {
          // Image is wider than matrix: fill height, crop sides
          drawHeight = cols;
          drawWidth = img.width * (cols / img.height);
          offsetX = (rows - drawWidth) / 2;
          offsetY = 0;
        } else {
          // Image is taller than matrix: fill width, crop top/bottom
          drawWidth = rows;
          drawHeight = img.height * (rows / img.width);
          offsetX = 0;
          offsetY = (cols - drawHeight) / 2;
        }
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, rows, cols);
        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        const imgData = ctx.getImageData(0, 0, rows, cols).data;
        for (let y = 0; y < cols; y++) {
          for (let x = 0; x < rows; x++) {
            const idx = (y * rows + x) * 4;
            const r = imgData[idx];
            const g = imgData[idx + 1];
            const b = imgData[idx + 2];
            matrix[x][y] = '#' +
              r.toString(16).padStart(2, '0') +
              g.toString(16).padStart(2, '0') +
              b.toString(16).padStart(2, '0');
          }
        }
        renderMatrixTable();
        sendMatrixDebounced();
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  });
  </script>
</body>
</html>
)html";